\appendix
\section{First Order Predicate Logic}
The purpose of this section is to introduce a framework for doing mathematics. We will choose first order logic \verb|FOL|.
\subsection{The Metatheory of First Order Logic}
\subsubsection{Classical Metatheory}
We assume a notion of \emph{finiteness}. With this notion consider symbols $\mathbf{0}$ and $\mathbf{s}$, from which we build a \emph{potentially infinite} list $\mathbf{N}$ of \emph{natural numbers} of finite strings formed by appending $\mathbf{s}$ to the left to the prior string in the list, where the list starts with $\mathbf{0}$. In other words the have a list
$$\mathbf{N} = [\mathbf{0},\mathbf{s0},\mathbf{ss0},\dots]$$ 
where $\dots$ signify that to look up the next string in the list, we concatenate from the right $\mathbf{s}$ the last formed string in the list. Each string is either the string $\mathbf{0}$ or $\sigma\mathbf{0}$, where $\sigma$ is some non-empty finite string of $\mathbf{s}$'s. We thus have the following for possibly empty strings of $\mathbf{s}$'s, $\sigma, \pi,\rho$
\begin{gather*}
    \sigma\pi \mathbf{0} = \pi\sigma \mathbf{0},\\
    \mathbf{s}\sigma\pi\mathbf{0} \equiv \mathbf{s}\pi\sigma\mathbf{0},\\
    \mathbf{s}\sigma\pi\mathbf{0}\equiv \sigma \mathbf{s}\pi\mathbf{0},\\
    \sigma\mathbf{0} \equiv \pi\mathbf{0} \metaiff \mathbf{s}\sigma\mathbf{0}\equiv \mathbf{s}\pi\mathbf{0},\\
    \sigma\mathbf{0}\equiv \pi\mathbf{0} \metaiff \sigma\rho\mathbf{0}\equiv \sigma\rho\mathbf{0}, 
\end{gather*}
where "$\equiv$" means "identical to". For two elements in $\mathbf{N}$, $n,m$ we write $n<m$ if $n$ is formed earlier in the list than $m$ and $n>m$ if $n$ is formed later in the list than $m$. By $n+1$ we mean the next element to be formed in the list. And if $n$ is not $\mathbf{0}$ we write $n-1$ to be the string formed Immediately before $n$. We define 
$$\sigma\mathbf{0}+\mathbf{0} :\equiv \sigma\mathbf{0} \text{ and } 0 + \pi\mathbf{0} :\equiv \pi\mathbf{0}$$
and 
$$\sigma\mathbf{0} + \pi\mathbf{0} :\equiv \sigma\pi \mathbf{0}.$$
We also have a principle of induction. I.e. if some statement $P$ holds for $\mathbf{0}$ and whenever $P$ holds for $n$, then it holds for $n+1$, then $P$ holds for all strings in $\mathbf{N}$.\\ 
We also have a principle of recursion. I.e. If we define $X_0$ and whenever $X_n$ is defined, so is $X_{n+1}$, then $X_m$ is defined for every string $m$ in $\mathbf{N}$.\\
Note here that we have implicitly introduced the notion of indexing. Given a finite list of objects, initialize a point on $\mathbf{N}$ at $\mathbf{0}$, pick out an element in the list of objects and assign the value point at in $\mathbf{N}$, move the point to the next element in $\mathbf{N}$ and move pick out the next element in the list of objects. This lets us consider a length $n$ list of object, e.g. $t_1,\dots,t_n$. These informal metamathematical concepts form a sufficient \emph{classical metatheory} for fist order logic. 
\subsubsection{Strong Metatheory}
Sometimes we need to strengthen our metatheory with \emph{the law of excluded middle} and \emph{naive set theory}. The first of these notions is that a statement is either true or false. The last of which is the notion that we can consider a sufficiently small (always finite) collection of objects and ask whether something is a member of such a collection. 
\subsection{The Alphabet of First Order Logic}
\subsubsection*{The Logical Symbols}
\verb|FOL| is a framework for formalizing different theories. It is therefor has to flexible enough to be augmented to work in a large variety of contexts and domains. We therefor make distinctions between the role of the symbols that comprise \verb|FOL|. The \emph{logical symbols} in the language of \verb|FOL| are those symbols that are not context specific. These are 
\begin{enumerate}
    \item \textbf{Variables}: These are play the role of placeholders for objects in the domain to which we want to apply \verb|FOL|. Eg. $x$ might be a placeholder for a set in Zermol-Fraenkel set theory or $n$ might be a placeholder for a natural number in the standard model of Peano arithemetic or $\mathcal{C}$ could be a placeholder for a category in Category Theory. We presuppose a potentially infinite list of such symbols. That is we may always generate sufficiently large number of distinct variables.
    \item \textbf{Logical operators:} $\neg$ (not), $\wedge$ (and), $\vee$ (or), $\to$ (implies).
    \item \textbf{Logical quantifiers:} $\forall$ (universal quantifier, to be read as "for all" or "for every") and $\exists$ (existential quantifier, to be read as "exists" or "there is").
    \item \textbf{Equality symbol:} $=$ a \emph{relational symbol} (scroll down a little for a definition) which is not context specific.    
\end{enumerate}
\subsubsection{The Non-logical Symbols}
Those symbols that are introduced in some context to use \verb|FOL| to talk about some domain. these are 
\begin{enumerate}
    \item \textbf{Constant symbols:} These are symbols that signify a specific object in a specific domain. Examples are $\emptyset$ in for example Zermelo-Fraenkel set theory or $0$ in Peano arithmetic.
    \item \textbf{Function symbols:} A symbol that is a placeholder for an object that depends on finite list of objects in a domain called arguments. For instance if $F$ is a function symbol that takes $n$ arguments, then given variables $x_1,\dots, x_n$, $F(x_1,\dots,x_n)$ is some object. A function symbol has a natural number attached to them called an \emph{arity}. A function symbol that takes $n$ arguments is an $n$-ary function. Examples are $+$ in Peano Arithmetic or $\cup$ in Zermelo-fraenkel set theory. 
    \item \textbf{Relation symbols:} Symbol that signify relations of objects. Like function symbols these have a natural number arity and given a relation symbol $R$ and objects $x_1,\dots, x_n$, $R(x_1,\dots,x_n)$ signifies that $x_1,\dots,x_n$ are in relation by $R$.  
\end{enumerate}
To actually give these syntactical meaning, we need to define rules for building well-formed. I.e. we need to define what strings of symbols we are allowed to write in the language. A set of non-logical symbols is called a \textit{signature} often denoted $\mathcal{L}$. 
\subsubsection{Terms and Formulae}
For a signature $\mathcal{L}$, a string of symbols is an \emph{$\mathcal{L}$-term} if it is a result of finitely applying these rules in some order
\begin{align*}
    \mathrm{T0}\colon\quad & \text{Each variable is an } \mathcal{L}\text{-term}.\\
    \mathrm{T1}\colon\quad & \text{Each constant symbol in }\mathcal{L} \text{ is an } \mathcal{L}\text{-term}.\\
    \mathrm{T2}\colon\quad & \text{If } \tau_1,\dots,\tau_n \text{ are any } \mathcal{L}\text{-terms and }F \text{ is an } n \text{-ary function symbol in } \mathcal{L}\text{,}\\
    &\text{then } F(\tau_1,\dots,\tau_n) \text{ is an } \mathcal{L}\text{-term}. 
\end{align*} 
When the symbols are not involving any non-logical symbols, it is called a \emph{term}. Those terms of the form $\mathrm{T0}$ or $\mathrm{T1}$ are called \emph{atomic terms}. Note that in the above, the $\tau$'s are placeholders for objects in the language \textbf{not} for objects in a domain of interest. If we want to prove a property $\Phi$ of terms, then we do that by proving that each of the three categories of terms satisfy $\Phi$, which is called the \emph{induction on term construction}.\\
An \emph{$\mathcal{L}$-formula} is a string of symbols resulting from finite application of the rules
\begin{align*}
    \mathrm{F0}\colon\quad & \text{For } \mathcal{L}\text{-terms } \tau_1,\tau_2\text{ then } \tau_1 = \tau_2\text{ is an } \mathcal{L}\text{-formula.}\\
    \mathrm{F1}\colon\quad & \text{For } \mathcal{L}\text{-terms } \tau_1,\dots,\tau_n \text{ and } R \text{ a non-logical } n\text{-ary relation symbol in }\mathcal{L},\\
     &\text{then } R(\tau_1,\dots,\tau_n) \text{ is an } \mathcal{L}\text{-formula.}\\
     \mathrm{F2}\colon\quad & \text{if }\varphi \text{ is an }\mathcal{L}\text{-formula, then } \neg\varphi \text{ is an }\mathcal{L}\text{-formula.}\\
     \mathrm{F3}\colon\quad & \text{if }\varphi \text{ and } \psi \text{ are } \mathcal{L}\text{-formulae, then } \varphi\to \psi, \varphi\wedge \psi \text{ and } \varphi\vee \psi \text{ are } \mathcal{L}\text{-formulae.}\\
     \mathrm{F4}\colon\quad &  \text{if }\varphi \text{ is an }\mathcal{L}\text{-formula, then given a variable }x\text{, } \exists x\varphi \text{ and } \forall x\varphi \text{ are } \mathcal{L}\text{-formulae.}  
\end{align*}
When an $\mathcal{L}$-formula is build from terms, it is simply called a \emph{formula}. $\mathrm{F0}$- and $\mathrm{F1}$-formulae are called \emph{atomic formulae}. The \emph{induction on formula construction} refers to the fact that proving a property $\Phi$ is satisfied by formulae, we can prove that it is satisfied for atomic formulae, and that for $\mathcal{L}$-formulae $\varphi,\psi$ satisfying $\Phi$, given a variable $x$, then $\neg\varphi,\varphi \wedge \psi,\varphi\vee\psi,\varphi\to \psi,\exists x\varphi,\forall x\varphi$ also satisfy $\Phi$.\\
Consider a variable $x$ and a formula $\varphi$ of the form $\forall x\psi$ or $\exists x\psi$. If $x$ is used to construct $\psi$ and does not immediately appear after a logical quantifier at some position in $\psi$, it is said to be in the \emph{range of} said logical quantifier. Such a variable is said to \emph{bound at that position} by the last quantifier that it is in the range of. A variable that is not bound by a quantifier at a particular position is said to be \emph{free} at position. A variable may appear in a formula as both bounded and free. For instance $(\forall x(x\neq x))\to \exists z(x=x)$. The first two occurences of $x$ are bound by the $\forall$ and the last two are bound by the $\exists$. The set of free variables of a formula (a rule given later will show that this set is uniquely defined) is denoted $\mathrm{free}(\varphi)$. A formula $\varphi$ is a \emph{sentence} if $\mathrm{free}(\varphi)=\emptyset$, so $x\neq x\to x=x$ is a formula while $\forall x(x\neq x\to x=x)$ is a sentence. A term is \emph{closed} if it contains no variables. For a formula $\phi$ and variables $x_1,\dots,x_n$ with $\{x_1,\dots, x_n\}\subset \mathrm{free}(\phi)$, we denote $\phi$ by $\phi(x_1,\dots,x_n)$. In the metalanguage of \verb|FOL|, we write $\varphi \equiv \psi$ for formulas, if the strings comprising these are identical.\\ 
When $\tau$ is a term and $x$ is a variable in $\tau$, for a term $\omega$, we get a new term by \emph{substituting} $x$ with $\omega$, i.e. by replacing every instance of $x$ by $\omega$, which we may do considering $\tau$ as unary function symbol in $\mathcal{L}$. We denote this new term by $\tau(x/\omega)$.\\ 
For a formula $\varphi$ and a variable $x$ and $\tau$ a term, $\varphi(x/\tau)$ is the formula obtained by replacing every free instance of $x$ in $\varphi$ by $\tau$. So we obtain a notion of substitution for formulas as well. A substition of $x$ in a formula $\varphi$ with a term $\tau$ is called \emph{admissible} if it is not in the range of a quantifier that binds a variable in $\tau$. If $x$ does not occur as a free variable in $\varphi$, then trivially $x$ is not bound hence, $\varphi(x/\tau)$ is admissible. In this case the string $\varphi$ is unchanged, since no instance $x$ is replaced by $\tau$. So $\varphi\equiv \varphi(x/\tau)$. In general, for an admissible substitution, we write $\varphi(\tau)$ instead of $\varphi(x/\tau)$. When we declare that a symbol, $\phi$, in the metalanguage denotes another, $\psi$, we write $\phi :\equiv \psi$. For instance, $\varphi(\tau) :=  \varphi(x/\tau)$. 
\subsection{Axioms and Inference Rules}
An \emph{axiom} is a special formula, which will be one ingredient in producing new formulas. In a looser sense (for now), think of axioms as statements that are valid in some context. Sometimes we also consider \emph{axiom schemae}, defined to be a collection axioms taken to be valid for every instance of some fixed list of function symbols, a fixed list of relation symbols and a fixed list of formulae.
\subsubsection{Logical Axioms: Assigning Truth Values to Formulae}
The \emph{logical axioms} are those axioms that are valid in any context. These are given by the following axiom schemae. Consider $\varphi,\varphi_1,\varphi_2,\varphi_3,\psi$ arbitrary formulae. We have formulae
\begin{align*}
    \mathrm{L0}\colon\quad & \varphi\vee \neg\varphi\\
    \mathrm{L1}\colon\quad & \varphi\to (\psi\to \varphi)\\
    \mathrm{L2}\colon \quad & (\psi\to (\varphi_1\to \varphi_2))\to ((\psi\to \varphi_1)\to (\psi\to \varphi_2))\\
    \mathrm{L3}\colon \quad & (\varphi\wedge \psi)\to \varphi\\
    \mathrm{L4}\colon \quad & (\varphi\wedge \psi)\to \psi\\
    \mathrm{L5}\colon \quad & \varphi\to (\psi\to (\varphi\wedge \psi))\\
    \mathrm{L6}\colon \quad & \varphi \to (\varphi\vee \psi)\\
    \mathrm{L7}\colon \quad & \psi \to (\varphi \vee \psi)\\
    \mathrm{L8}\colon \quad & (\varphi_1\to \varphi_3)\to ((\varphi_2\to \varphi_3)\to ((\varphi_1\vee \varphi_2)\to \varphi_3 ))\\
    \mathrm{L9}\colon \quad & \neg\varphi \to (\varphi \to \psi).
\end{align*}
Moreover if $x$ is a variable in $\varphi$ and $\tau$ a term such that $\varphi(x/\tau)$ is admissible, then 
\begin{align*}
    \mathrm{L10}\colon \quad & \forall x\varphi(x) \to \varphi(\tau)\\
    \mathrm{L11}\colon \quad & \varphi(\tau)\to \exists x\varphi(x). 
\end{align*}
Suppose $x$ is a variable of $\psi$ with $x\notin\mathrm{free}(\psi)$. Then 
\begin{align*}
    \mathrm{L12}\colon \quad & \forall x(\psi\to \varphi(x))\to (\psi\to \forall x\varphi(x))\\
    \mathrm{L13}\colon \quad & \forall x(\varphi(x)\to \psi)\to (\exists\varphi(x)\to \psi).
\end{align*} 
Lastly we have axioms for the binary relational symbol $=$. Let $\tau,\tau_1,\dots,\tau_n,\tau_1',\dots,\tau_n'$ be terms and $R$ an $n$-ary relation symbol and $F$ an $n$-ary function symbol.
\begin{align*}
    \mathrm{L14}\colon \quad & \tau = \tau\\
    \mathrm{L15}\colon \quad & \tau_1 = \tau_1' \wedge \dots \wedge \tau_n = \tau_n' \to (R(\tau_1,\dots,\tau_n)\to R(\tau_1',\dots,\tau_n'))\\
    \mathrm{L16}\colon \quad & \tau_1 = \tau_1' \wedge \dots \wedge \tau_n = \tau_n' \to (F(\tau_1,\dots,\tau_n)\to F(\tau_1',\dots,\tau_n'))  
\end{align*}
We use $:\iff$ to define relations on symbols in metalanguage of \verb|FOL|. For instance, we define for formulae $\varphi,\psi$, terms $\tau,\tau'$ and a variable $x$, 
\begin{gather*}
    \varphi \leftrightarrow \psi :\iff (\varphi \to \psi \wedge \psi \to \varphi)\\
    \exists! x\varphi :\iff \exists x\varphi(x) \wedge \forall y(\varphi(y)\to x=y)\\
    \tau \neq \tau' :\iff \neg(\tau = \tau').
\end{gather*}

\subsubsection{Non-logical Axioms: Defining a Theory}
To the logical axioms we may add a set of formulae, formed from a signature $\mathcal{L}$, which we call an \emph{$\mathcal{L}$-theory}. Examples of non-logical axioms are those of, \verb|ZF|-axioms which forms Zermelo-Fraenkel set theory, the axioms of topology which forms the theory of topology, \verb|PA|-axioms which forms number theory, etc. For mathematical theories such axioms are always sentences.  
\subsubsection{Proofs}
To deduce new formulas from the axioms of some $\mathcal{L}$-theory, we two \emph{inference rules}: 
$$\infer{\psi}{\varphi \to \psi & \varphi} \quad \quad \quad\text{and}\quad \quad \quad  \infer{\forall x \varphi}{\varphi}.$$
These are called \emph{modus ponens} and \emph{generalization} respectively.\\
We want to use the notion of axiom and inference rule to prove statements in different $\mathcal{L}$-theories. Let $\Phi$ be a finite set of $\mathcal{L}$-formulae and $\psi$ be an $\mathcal{L}$-formula. We say that \emph{$\psi$ is provable from $\Phi$}, denoted $\Phi\vdash \psi$ if there are $\mathcal{L}$-formulae $\varphi_1,\dots,\varphi_n$, called \emph{a formal proof of $\psi$} satisfying $\varphi_n\equiv \psi$ and for $i\leq n$ $\varphi_i$ satisfies one of the following conditions 
\begin{enumerate}
    \item It is a logical axiom.
    \item It is an element of $\Phi$
    \item There are $j,k< i$ such that $\varphi_j\equiv \varphi_k \to \varphi_i$.
    \item There is a $j<i$ with $\varphi_i \equiv \forall x \varphi_j$, where $x\notin \mathrm{free}(\phi)$ for any of the $\phi\in \Phi$.
\end{enumerate} 
We take $\vdash \psi$ to mean $\emptyset \vdash \psi$. In this case $\psi$ is called a \emph{tautology}. $\Phi$ is called a \emph{context}. If $\psi$ has no formal proof in a fixed context $\Phi$, we write $\Phi \not\vdash \psi$. Rather than writing down formal proofs down in, for instance, a box proof, we will just note that this is possible to do. Instead, we will write proofs in natural language in such a way that it to a sufficiently knowledgeable reader is somewhat clear what a formal proof would look like. At a certain point we also formulate formulae in natural language. Additionally we take certain basic proofs in \verb|FOL| for granted. This treatment of \verb|FOL| only serves to provide a clear and precise language for building mathematical theory and we will quickly become satisfied that it exists and be happy that if we properly formulate theory in natural language it will be formalizable in \verb|FOL|.  
\subsubsection{Tautology and Logical Equivalence}
We say that formulae $\varphi$ and $\psi$ are \emph{logically equivalent} if $\vdash \varphi \leftrightarrow \psi$. We write 
$$\varphi \iff \psi \iff_{\mathrm{meta}} \vdash \varphi \leftrightarrow \psi.$$
If $\Phi \vdash \varphi \leftrightarrow \psi$, we write $\varphi \iff_\Phi \psi$. In a natural language context, $\Phi$ will be a sequence of sentences in natural language and will not explicitly be written as a finite set, so therefore we usually just write $\varphi \iff \psi$ if we want to symbolically express that $\varphi$ is equivalent to $\psi$ in a given context (it should then be clear what the context is). 
\subsubsection{Proofs in Natural Deduction}
A different approach to building a system of deduction in \verb|FOL| is to write inference rules which tells us how to introduce and eliminate certain formulae to obtain new formulae. There is a different notion of proof in natural deduction. Luckily this approach is equivalent to that of introducing logical axioms, modus ponens and generalization. So when building proofs, we can also apply introduction and elimination rules. 

\subsubsection{Consistency and Compactness}
To discuss the notion of consistency we first introduce the notion of \emph{ex falso quodlibet}. given formulae $\varphi$ and $\psi$, this is $\{\varphi,\neg \varphi\}\vdash \psi$. It is proven in the following way: we get $\varphi$ and $\neg \varphi$ from the context. From modus ponens applied to $\neg\varphi \to (\varphi \to \psi)$ (from $\mathrm{L}9$) and $\neg \varphi$ we get $\varphi\to \psi$. Applying modus ponens to $\varphi\to \psi$ and $\varphi$ we get $\psi$ as desired. An \emph{ex falso quadlibet introduction} is $\Phi\vdash \varphi\wedge neg\varphi$. \\
A set of formulae $\Phi$ is called consistent if $\Phi\not\vdash \varphi \wedge \neg\varphi$ for any formula $\varphi$. We denote this by $\mathrm{Con}(\varphi)$. A set of formulae that is not consistent is called \emph{inconsistent}, denoted $\neg\mathrm{Con}(\Phi)$.     

\subsection{Semantics of First Order Logic}
We are now going to assign truth values to formulae. That is we want for some signature $\mathcal{L}$ to assign either false or true to each $\mathcal{L}$-formula. In propositional logic this can be done by asserting truth tabels for logical connectives, $\wedge$, $\vee$, $\neg$, $\to$. This simple approach does not extend to \verb|FOL|. Take for instance the formula, $\forall x \exists y \varphi(x,y)$. Could we possibly assign a truthtable to such a formula. Suppose for instance that $\varphi\equiv x<y$. Then there is a dependency on what $x$ and $y$ is and we are therefor at a loss in computing a truth table in terms of $\varphi$ in general. Introducing an algorithm for determining truth for $\forall$ and $\exists$ is not terrible, but we need a way to map formulas onto some sort of context. To discuss how to do this we need the notion of an \emph{interpretatation} for which we will assume some notion of naive set theory and a notion of law of excluded middle, i.e. we assume that a statement (to be interpreted informally) is either true or false. We are thus working in the strong metatheory.
\subsubsection{Structures and Interpretations}
given a signature $\mathcal{L}$ an $\mathcal{L}$-structure $M$ is a pair of a non-empty set $A$ (the domain of $M$) and a mapping from $\mathcal{L}$ to $A$ taking constant symbols $c\in \mathcal{L}$ to an element $c^M\in A$, $n$-ary relation symbols $R\in \mathcal{L}$ to a set of $n$-tuples $R^M\subset A^n$ and $n$-ary function symbols $F$ to a function $F^M: A^n \rightarrow A$. An \emph{assignment} on an $\mathcal{L}$-structure $M$ is a mapping, $\iota$, taking variables $x$ in $\mathcal{L}$ to $A$. An $\mathcal{L}$-interpretation $I$ is then a pair consisting of an $\mathcal{L}$-structure $M$ and an assignment $\iota$ on $M$ where to a variable $x\in \mathcal{L}$ and an element $a\in A$, we define for variables $y$ in $\mathcal{L}$
$$
    \iota[x\mapsto a] (y)=
    \begin{cases}
        a & \text{if } x\equiv y\\
        \iota(y) & \text{else}
    \end{cases}
$$
$\iota[x\mapsto a]$ is thus itself an assigment on $M$. We define 
$$I[x\mapsto a] := (M,\iota[x\mapsto a]).$$
For an $\mathcal{L}$-term $\tau$ we define $I(\tau)\in A$ by recursion on terms in the following way: On a variable $x$, $I(x):=\iota(x)$, on a constant $c$, $I(c):= c^M$, for an $n$-ary function symbol and terms $\tau_1,\dots,\tau_n$, $I(F(\tau_1,\dots,\tau_n)):= F^M(I(\tau_1),\dots,I(\tau_n)).$ We now define how to assign truth value to formulae under an interpretation. When a formula $\varphi$ is true in an interpretatation $I$ we write $I\vDash \varphi$. This mapping is constructed inductively on symbols that are used to construct formulae. So for instance given terms $\tau_1,\tau_2$ and variable $x$, $I\vDash \tau_1=\tau_2 :\iff_{\mathrm{meta}} I(\tau_1) = I(\tau_2)$ and $I\vDash \exists x \varphi: \iff_{\mathrm{meta}}\ \mathrm{there}\ \mathrm{exists}\ a\ \mathrm{in}\ A: \ I[x\mapsto a]\vDash \varphi$ and $I\vDash \neg\varphi :\iff_{\mathrm{meta}} I\vDash \varphi \text{is not true}$. I.e. we translate truth of a formula in some interpretation to statements in the metatheory. I feel that there is only a need to illustrate the idea as I don't want to write all of the rules down. Under the assumption of classical logic in the meta theory, we now have that $I \vDash \varphi \ \mathrm{or} \ I\vDash \neg \varphi$. It is still necessarily true that $\Phi \vdash \varphi$ or $\Phi \vdash \neg\varphi$. That is there may be statements in some theory that is true but not provable or a statement that is true but where $\Phi \vdash \varphi$.\\
Given a set of $\mathcal{L}$-formulae $\Phi$ and an $\mathcal{L}$-structure $M$, we say that\emph{$M$ is a model of $\Phi$} if for for every assignment $\iota$ and for each $\varphi\in \Phi$, 
$$(M,j) \vDash \varphi.$$
If this is the case, we write 
$$M\vDash \Phi.$$
We note that one can construct a signature $\mathcal{L}$ and a domain $A$ for which there is a set of sentences $\Phi$ and two $\mathcal{L}$-structures $M_1$ and $M_2$ where $M_1$ is a model of $\Phi$ and $M_2$ is not. Take $\mathcal{L}=\{c,f\}$ where $c$ is constant and $f$ is a unary function symbol, $A=\{0,1\}$ and $\Phi = \{\varphi_1,\varphi_2\}$ with $\varphi_1 :\equiv\forall x(x=c\vee x=f(c))$ and $\varphi_2:\equiv \exists(x\neq c)$. Now we define $c^{M_1} :=0$, $f^{M_1}(0)=1, f^{M_2}(1)=0$ and $c^{M_2}:=0, f^{M_2}(0)=0,f^{M_2}(1)=1$. Fix an assignment. {\Large do example later}.\\
\subsubsection{Universal closure}

\subsubsection{Isomorphisms of $\mathcal{L}$-structures}

\subsubsection{Soundness and the Soundness Theorem}

\subsection{Gödels Completeness Theorem}

\subsection{The Axioms and Standard Model of Peano Arithmetic}

\subsubsection{The Axioms}
We introduce to the language of first order predicate logic the following symbols, $\mathcal{L}_{\mathrm{PA}}:=\{0,\mathrm{s},+,\cdot\}$ and these symbols make up the language of Peano Arithmetic ($\verb|PA|)$. The axioms of Peano arithmetic are as follows. 
    \begin{axioms}
        \begin{align*}
            \mathrm{PA}_0\colon\quad & \neg \exists x (\mathrm{s} x = 0) \\
            \mathrm{PA}_1\colon\quad & \forall x \forall y (\sverb x = \sverb y \rightarrow x = y) \\
            \mathrm{PA}_2\colon\quad & \forall x (x + 0 = x) \\
            \mathrm{PA}_3\colon\quad & \forall x \forall y (x + \sverb y = \sverb(x + y)) \\
            \mathrm{PA}_4\colon\quad & \forall x (x \cdot 0 = 0) \\
            \mathrm{PA}_5\colon\quad & \forall x \forall y (x \cdot \sverb y = (x \cdot y) + x) \\
            \mathrm{PA}_6\colon\quad & \left( \varphi(0) \land \forall x (\varphi(x) \rightarrow \varphi(\sverb (x))) \right) \rightarrow \forall x \varphi(x)
        \end{align*}
    \end{axioms}
\subsubsection{The Standard Model}
For the standard model we let the domain be $\N$, i.e. the naive notion of natural numbers we described earlier consisting of $\mathbf{0}$ and finite strings of the form $\mathbf{s}\dots \mathbf{s}\mathbf{0}$. 


\subsubsection{Gödels Incompleteness Theorem}
